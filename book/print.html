<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ink Bottled Lemonade</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="FOREWORD.html"><strong aria-hidden="true">2.</strong> Foreword</a></li><li class="chapter-item expanded affix "><li class="part-title">Articles</li><li class="chapter-item expanded "><a href="boomerang.html"><strong aria-hidden="true">3.</strong> Motion Control</a></li><li class="chapter-item expanded "><a href="2024-01-24-Basic-Odometry.html"><strong aria-hidden="true">4.</strong> Basic Odometry</a></li><li class="chapter-item expanded "><a href="2024-2-2-Basic-PID.html"><strong aria-hidden="true">5.</strong> Basic PID</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2024-02-06-Bang-Bang.html"><strong aria-hidden="true">5.1.</strong> Bang Bang</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="Contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ink Bottled Lemonade</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motion-control"><a class="header" href="#motion-control">Motion Control</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: Basic Odometry
author: Tropix
date: 2024-01-24 10:12:00 -0700
categories: [Odometry, Introductory]
tags: [software,odometry]     # TAG names should always be lowercase
image:
path: https://i.postimg.cc/grFzjG4w/Tropical-pfp.png
width: 640 #correct image size
height: 480</h2>
<h1 id="odometry"><a class="header" href="#odometry">Odometry</a></h1>
<p><em>How does a robot know where it is?</em></p>
<p>Odometry is a method of tracking the absolute position of a robot on a field using sensor data. While it's often viewed as a complicated process, the code behind it can be relatively simple. This tutorial explains the math behind odometry and outlines how to create a basic position tracking function that works similarly to the one used in taolib.</p>
<h2 id="the-basics"><a class="header" href="#the-basics">The basics</a></h2>
<p>The general idea behind tracking the robot's position is as follows:</p>
<ul>
<li>Measure the total distance that the robot has traveled using wheel encoders.</li>
<li>Measure the absolute heading of the robot using either encoders or a gyroscope (we'll be using the <a href="https://www.vexrobotics.com/276-4855.html">V5 Inertial Sensor</a>).</li>
<li>Create a loop that measures the distance that our wheel encoders have traveled from the last loop run, then imagine that distance as the hypotenuse of a right triangle. The robot's current heading at the time of the loop is the base angle of the triangle.</li>
<li>By forming this triangle, some basic trigonometry can be used to find the length of the triangle's opposite and ajacent sides. The length of these sides are how far the robot has traveled in the X and Y direction.</li>
<li>Repeat this process using our loop at a very fast rate (ideally once every 10 milliseconds).</li>
</ul>
<p>To visualize the last two steps, let's use an image:</p>
<p><img src="https://i.imgur.com/4Edofqi.png" alt="Odometry Math" /></p>
<p>To find the change in X and Y, we'll use the following formulas.</p>
<pre><code class="language-cpp">change_in_x = change_in_distance * cos(heading)
change_in_y = change_in_distance * sin(heading)
</code></pre>
<h2 id="lets-write-an-implementation"><a class="header" href="#lets-write-an-implementation">Let's write an implementation</a></h2>
<h3 id="finding-wheel-travel"><a class="header" href="#finding-wheel-travel">Finding Wheel Travel</a></h3>
<p>The first step is measuring how far the wheels have traveled forward or backward. This can be done using motor encoders.</p>
<p>We can get the degrees of travel from each encoder using <code>Motor.position(vex::degrees)</code> (this also works for motor groups). For the most accuracy, we'll take the average of all motors in the drivetrain and use that as our total distance value.</p>
<pre><code class="language-cpp">double average_encoder_position = (LeftMotors.position(vex::degrees) + RightMotors.position(vex::degrees)) / 2;
</code></pre>
<p>Now we have data on how far the encoders have turned in degrees, but how do we convert those degrees to a distance unit like inches?</p>
<p>Every time a motor encoder spins a full 360 degrees (1 "revolution"), the drivetrain will have traveled the circumference of the wheel being driven. We aren't quite done yet, though. If the drivetrain has a <a href="https://wiki.purduesigbots.com/hardware/design-fundamentals/gear-ratios">gear ratio</a>, then we need to factor that into the distance equation. The final formula for degrees to distace is <code>(average_encoder_position / 360) * wheel_circumference * external_gear_ratio)</code>.</p>
<pre><code class="language-cpp">#include &lt;cmath&gt;

constexpr double gear_ratio = ((double)84/60); // Using an 84/60 gear ratio for this example.
constexpr double wheel_radius = 2;
constexpr double wheel_circumference = 2 * M_PI * wheel_radius;

double average_encoder_position = (LeftMotors.position(vex::degrees) + RightMotors.position(vex::degrees)) / 2;
double distance_traveled = (average_encoder_position / 360) * wheel_circumference * gear_ratio;
</code></pre>
<h3 id="finding-heading"><a class="header" href="#finding-heading">Finding Heading</a></h3>
<p>The next thing we need is to determine where the robot is facing. The easiest way is to use the gyroscope of the <a href="https://www.vexrobotics.com/276-4855.html">V5 Inertial Sensor</a>, so we'll go over that first.</p>
<blockquote>
<p><em>WARNING:</em> Be sure to <a href="https://www.vexforum.com/t/how-do-i-calibrate-inertial-sensor-in-pre-auton/74040">calibrate your Inertial Sensor</a> at the start of <code>pre_auton</code>, or else the headings that it reports will be wrong!</p>
</blockquote>
<p>You can find the absolute heading of the drivetrain in degrees using the <code>Inertial.heading(vex::degrees)</code> function. There are a few things wrong with this value, though. First, the sensor reports heading as increasing in the clockwise direction, meaning that heading will <em>increase</em> as the robot turns <em>right</em>. For the purposes of position tracking, this will alter how our robot's coordinates are reported, so this value will need to be converted to a counterclockwise angle.</p>
<pre><code class="language-cpp">double heading = 360 - Inertial.heading(vex::degrees);
</code></pre>
<p>The next problem is that the sensor treats "0 degrees" as the robot's starting angle. This is generally a bad idea for position tracking, because we want "forward" to be up on the y-axis for easy visualization. <strong>In most cases, you want to imagine the robot's starting angle as 90 degrees.</strong></p>
<p><img src="https://i.imgur.com/tZE6Mxy.png" alt="Starting at 0 degrees vs starting at 90 degrees" /></p>
<p>To make this adjustment, we can simply add <code>90</code> to the heading value after converting it to coutnerclockwise degrees. We'll also use the <code>std::fmod</code> function of the standard library to wrap the heading back to 0 once we reach 360 degrees after offsetting.</p>
<pre><code class="language-cpp">#include &lt;cmath&gt;

double start_heading = 90;

// Using std::fmod to preserve the "wraparound effect" of 0-360 degrees when considering the offset of start heading.
double heading = std::fmod((360 - Inertial.heading(vex::degrees)) + start_heading, 360);
</code></pre>
<h3 id="finding-heading-without-an-inertial-sensor"><a class="header" href="#finding-heading-without-an-inertial-sensor">Finding Heading (without an inertial sensor)</a></h3>
<p>If you don't have access to an inertial sensor, then absolute heading <em>can</em> be estimated using wheel encoders only. Keep in mind that this will be less accurate than if you had an appropriate sensor.</p>
<p>The formula for finding heading with encoders is as follows:</p>
<pre><code>heading_in_radians = (right_distance - left_distance) / track_width
</code></pre>
<p>Right and left distances can be found similarly to how <code>distance_traveled</code> is found, but using only one side of the drivetrain.</p>
<pre><code class="language-cpp">double left_distance = (LeftMotors.position(vex::degrees) / 360) * wheel_circumference * external_gear_ratio;
double right_distance = (LeftMotors.position(vex::degrees) / 360) * wheel_circumference * external_gear_ratio;
</code></pre>
<p>Next we need to find track width. Track width is a measurement of the distance between the center of your left and right wheels. This measurement will be unique to different drivetrains, and should be measured in the same units that <code>wheel_radius</code> is measured with.</p>
<p><img src="https://kb.vex.com/hc/article_attachments/360085801912/track_width.jpg" alt="Track width measurement" /></p>
<p>For the purpose of example, let's say our track width is 13.75 inches. We can now find our absolute heading in radians.</p>
<pre><code class="language-cpp">constexpr double track_width = 13.75;

double left_distance = (LeftMotors.position(vex::degrees) / 360) * wheel_circumference * external_gear_ratio;
double right_distance = (LeftMotors.position(vex::degrees) / 360) * wheel_circumference * external_gear_ratio;

double heading_in_radians = (right_distance - left_distance) / track_width;
</code></pre>
<p>The next step is to convert the heading to degrees and restrict it to 0 &lt;= x &lt; 360 (if the heading exceeds 360 degrees it will be reset to 0). This will mimick the heading reported by an inertial sensor's gyro.</p>
<p>We'll also add a <code>start_heading</code> of 90 degrees (explained in the previous section).</p>
<pre><code class="language-cpp">#include &lt;cmath&gt;

constexpr double track_width = 13.75;
constexpr double start_heading = 90;

double left_distance = (LeftMotors.position(vex::degrees) / 360) * wheel_circumference * external_gear_ratio;
double right_distance = (LeftMotors.position(vex::degrees) / 360) * wheel_circumference * external_gear_ratio;

double heading_in_radians = (right_distance - left_distance) / track_width;

double heading = std::fmod((360 - (heading_in_radians * (180 / M_PI))) + start_heading, 360);
</code></pre>
<h2 id="making-a-loop"><a class="header" href="#making-a-loop">Making a loop</a></h2>
<p>Now that we can measure the correct heading and distance values, let's put these together into a loop that can track the change in X and Y position.</p>
<p>We can create a basic loop inside of a function like so:</p>
<pre><code class="language-cpp">#include "vex.h"

double x = 0;
double y = 0;

void odometry() {
    while (true) {
        vex::this_thread::sleep_for(10);
    }
}
</code></pre>
<p>This creates a <code>while</code>-loop that will run forever and wait 10 milliseconds in between each cycle. We store global <code>x</code> and <code>y</code> variables for keeping track the robot's absolute x and y position.</p>
<blockquote>
<p>We wait 10 milliseconds for two reasons. First, an infinite loop on the V5 Brain without a wait condition will hog resources until the program freezes. Second, motor encoders can only report their values once every 10 milliseconds, meaning it would be wasteful to run these calculations any faster.</p>
</blockquote>
<p>We can now introduce our sensor readings to the loop.</p>
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include "vex.h"

constexpr double gear_ratio = ((double)84/60); // Using an 84/60 gear ratio for this example.
constexpr double wheel_radius = 2;
constexpr double wheel_circumference = 2 * M_PI * wheel_radius;
constexpr double start_heading = 90;

double x = 0;
double y = 0;

void odometry() {
    LeftMotors.resetPosition();
    RightMotors.resetPosition();

    while (true) {
        double heading = std::fmod((360 - Inertial.heading(vex::degrees)) + start_heading, 360);

        double average_encoder_position = (LeftMotors.position(vex::degrees) + RightMotors.position(vex::degrees)) / 2;
        double distance_traveled = (average_encoder_position / 360) * wheel_circumference * gear_ratio;

        vex::this_thread::sleep_for(10);
    }
}
</code></pre>
<p>Every time the loop runs we'll find the new heading and travel distance. These are the numbers that will eventually be used for the odometry formula.</p>
<h3 id="putting-it-together"><a class="header" href="#putting-it-together">Putting it together</a></h3>
<p>Let's perform the odometry calculations to find the change in x and y position. The calculations use our absolute heading and the distance that the robot has traveled since the <em>last loop cycle</em> (Î”distance).</p>
<p>We can find this change distance by storing the distance that the robot traveled at the start of the last loop cycle, and subtracting it from the current distance reading in the next cycle.</p>
<pre><code class="language-cpp">void odometry() {
    LeftMotors.resetPosition();
    RightMotors.resetPosition();

    double previous_distance_traveled = 0;

    while (true) {
        ...
        double distance_traveled = (average_encoder_position / 360) * wheel_circumference * gear_ratio;
        double change_in_distance = distance_traveled - previous_distance_traveled;

        ...

        // At the end of the loop, set previous_distance_traveled for the next loop iteration
        previous_distance_traveled = distance_traveled;

        vex::this_thread::sleep_for(10);
    }
}
</code></pre>
<p>This effectively tells us how far the robot has traveled in the 10 milliseconds it took to calculate the new positions. Now that we have this reading, we can use it to find our change in x and y.</p>
<blockquote>
<p>Keep in mind that C++'s trig functions operate on radians, so when providing heading we should multiply <code>heading</code> by <code>M_PI / 180</code> to convert degrees to radians.</p>
</blockquote>
<pre><code class="language-cpp">x += change_in_distance * std::cos(heading * (M_PI / 180));
y += change_in_distance * std::sin(heading * (M_PI / 180));
</code></pre>
<p>Adding everything together, your loop should now look like this:</p>
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include "vex.h"

constexpr double gear_ratio = ((double)84/60); // Using an 84/60 gear ratio for this example.
constexpr double wheel_radius = 2;
constexpr double wheel_circumference = 2 * M_PI * wheel_radius;
constexpr double start_heading = 90;

double x = 0;
double y = 0;

void odometry() {
    LeftMotors.resetPosition();
    RightMotors.resetPosition();

    double previous_distance_traveled = 0;

    while (true) {
        double heading = std::fmod((360 - Inertial.heading(vex::degrees)) + start_heading, 360);

        double average_encoder_position = (LeftMotors.position(vex::degrees) + RightMotors.position(vex::degrees)) / 2;
        double distance_traveled = (average_encoder_position / 360) * wheel_circumference * gear_ratio;

        double change_in_distance = distance_traveled - previous_distance_traveled;
        
        x += change_in_distance * std::cos(heading * (M_PI / 180));
        y += change_in_distance * std::sin(heading * (M_PI / 180));

        // At the end of the loop, set previous_distance_traveled for the next loop iteration
        previous_distance_traveled = distance_traveled;

        vex::this_thread::sleep_for(10);
    }
}
</code></pre>
<p>We now have a loop that will track the robot's absolute coordinates. But what next? How should we run it?</p>
<h3 id="starting-odometry-as-a-thread"><a class="header" href="#starting-odometry-as-a-thread">Starting odometry as a thread</a></h3>
<p>To use the coordinates found in our loop, we want to run the <code>odometry</code> function in the background. We do this using a technique called <a href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)">threading</a>. Using a separate thread means we can get position updates while moving the robot around or running an autonomous routine.</p>
<p>We'll start our odometry thread at the beginning of the autonomous period by creating a <code>vex::thread</code> instance, and passing in our <code>odometry</code> function:</p>
<pre><code class="language-cpp">// Autonomous function found in the VEX competition template
// If you aren't using the competition template, feel free to start this in main().
void autonomous() {
    // Start our odometry thread.
    // The odometry loop will run in the background while we move.
    vex::thread odometry_thread(odometry);

    // Spin our drivetrain forward for 2 seconds.
    LeftMotors.spin(vex::forward);
    RightMotors.spin(vex::forward);

    vex::wait(2, vex::seconds);

    LeftMotors.stop();
    RightMotors.stop();

    // Print where we ended up on the coordinate plane onto the brain screen.
    Brain.Screen.print("(%f, %f)", x, y);
}
</code></pre>
<h3 id="tracking-wheels"><a class="header" href="#tracking-wheels">Tracking Wheels</a></h3>
<p>Some teams may opt to use tracking wheels rather than integrated motor encoders. These are unpowered wheels attached to the bottom of the drivetrain that are hooked to external encoders. Using deadwheels has the advantage of preventing wheel slipping from messing up the readings for finding wheel travel distance.</p>
<p><img src="https://www.vexforum.com/uploads/default/original/2X/a/a90abb6db94c9fe8bddc0c284bc9f69bda97bd6e.png" alt="Tracking wheels" /></p>
<p>The math for finding distance traveled using tracking wheels is almost exactly the same as with motor encoders, except tracking wheels always have an implied 1:1 gear ratio:</p>
<pre><code class="language-cpp">constexpr double tracking_wheel_radius = 2;
constexpr double tracking_wheel_circumference = 2 * M_PI * tracking_wheel_radius;

double average_encoder_position = (LeftEncoder.position(vex::degrees) + RightEncoder.position(vex::degrees)) / 2;
double distance_traveled = (average_encoder_position / 360) * tracking_wheel_circumference;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: Basic PID
author: Prahas
date: 2024-02-2 08:03:00 -0700
categories: [PID, Introductory]
tags: [software, pid, beginner]     # TAG names should always be lowercase</h2>
<h1 id="pid"><a class="header" href="#pid">PID</a></h1>
<p><em>How do you control motors quickly and efficiently?</em></p>
<p>PID is a method of controlling motors using sensor data. While it's often viewed as a complicated process, the code behind it can be relatively simple. This tutorial explains the math behind PID and outlines how to create a basic PID controller similar to ones used in large libraries like LemLib and JAR.</p>
<p>PID stands for</p>
<blockquote>
<p><strong>P</strong>roportional
<strong>I</strong>ntegral
<strong>D</strong>erivative</p>
</blockquote>
<hr />
<h1 id="proportional"><a class="header" href="#proportional">Proportional</a></h1>
<p>To begin with, all PID calculations are based off of the <code>error</code>. The error is the difference in the target and the current sensor value of the motor.
<code>error = target - current</code>
So for example, if we want the motor to move to 100 degrees, but the motor is currently 20 degrees, the
<code>error = 100 - 20 = 80</code></p>
<p>The first and simplest term in PID is the proportional term. The proprtional term is as the name suggests. It is proportional to the error. <code>proportional = kP * error</code> where kP is a constant that needs to be tuned by the user. Too low will make the motor reach the target slowly while too high can cause the motor to go past the target and oscillate. Right now, the output would be only the proportional. This alone is better as opposed to a singular speed for motor control because with a P loop, the motor essentially goes faster when far away from a target and slower when closer to the target</p>
<h2 id="writing-an-implementation"><a class="header" href="#writing-an-implementation">Writing an Implementation</a></h2>
<h3 id="finding-motor-travel"><a class="header" href="#finding-motor-travel">Finding Motor Travel</a></h3>
<p>The first step is measuring how much progress the motors have made. This can be done using motor encoders. Finding this value will be different for every use case of PID. For example, for linear flywheel PID, you might use <code>double pros::Motor::get_actual_velocity ( )</code> while for lifts, you might use <code>double pros::Motor::get_position();</code></p>
<pre><code class="language-cpp">#include "main.h"

pros::Motor lift(1, pros::E_MOTOR_GEARSET_18); // motor at port 1, green gearbox
// function to get lift motor to the target angle
void P_loop(float target, float kP) {
    float error = 0;
    float P = 0;
    while (error != 0) {
        error = target - lift.get_position(); // update error
        P = error * kP;                       // update proportional
        lift.move(P);                         // update motor velocity
    }
}

void autonomous() {
    P_loop(90, 0.6); // move lift motor to 90 degrees with kP = 0.6
}
</code></pre>
<p>This code is mostly ok except for one issue. The loop only runs while the error is not equal to 0. The issue is that the loop will run forever as it isn't possible nor necessary to get the motor to such a precise number. This can be solved by making a range of values when the controller can exit or otherwise known as a<code>deadband</code>. We can check if the absolute value of the error is below deadband like so.</p>
<pre><code class="language-cpp">float deadband = 1;
while (fabs(error) &gt; deadband)){
    // control loop code
}
</code></pre>
<blockquote>
<p>fabs() is a standard c++ function that returns the absolute value of a <code>float</code> datatype!</p>
</blockquote>
<p>This will be the same units as the sensor units you use. So for this example, a deadband of 1 is a settle range of 1 degree.</p>
<h1 id="integral"><a class="header" href="#integral">Integral</a></h1>
<p>The next term in PID is the integral term.</p>
<p>The issue with just using the proportional term is that in some cases, the proportional gets too small when close to the target like in this simulation below.</p>
<iframe src="https://www.desmos.com/calculator/dmkizquwlc?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>
<p>This is called steady-state error and in real life, sometimes the motor halts right before the target.</p>
<p>The integral term can help fix this. The <code>integral</code> is the area under a function on a graph like below.</p>
<iframe src="https://www.desmos.com/calculator/ite1iqprlv?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>
<p>Since we are integrating the error, the integral is basically the sum of the error. Thus, integral can be calculated simply by summing up the error.</p>
<pre><code class="language-cpp">float integral = 0;

while...// inside the loop
inegral += error;
</code></pre>
<p>Sometimes the  <code>integral</code> term may be too high or too low which is why there is also a constant for the integral-<code>kI</code>.</p>
<pre><code class="language-cpp">float I = integral * kI;
</code></pre>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<pre><code class="language-cpp">#include "main.h"
#include  &lt;cmath&gt;  // Include cmath for fabs()
pros::Motor lift(1, pros::E_MOTOR_GEARSET_18); // motor at port 1, green gearbox

// function to get lift motor to the target angle
void PI_loop(float target, float deadband, float kP, float kI) {
    float error = 0;
    float integral = 0;
    float P = 0;
    float I = 0;
    while (fabs(deadband &gt; error)) {
        error = target - lift.get_position();
        integral += error;
        P = error * kP;
        I = integral * kI;
        lift.move(P + I);
    }
}

void autonomous() {
	// move lift motor to 90 degrees with deadband = 1, kP = 0.6, and kI = 0.1
    PI_loop(90, 1, 0.6, 0.1); 
}
</code></pre>
<h1 id="derivative"><a class="header" href="#derivative">Derivative</a></h1>
<p>The derivative is the rate of change of a function. If a function is increasing very quickly, the derivative will be large. Otherwise, if a function is decreasing, the derivative will be negative.</p>
<p>Because the derivative is the rate of change of the error, when it is added to the output, it will increase the motor power faster when accelerating and will  increace the deacceleration amount.</p>
<p>But it can also be flipped so that it is negative while the motor power is increasing and positive while the motor is deccelerating. This can lead to the velocity of the motor dampening and more accurate/controlled results.</p>
<p>If the constant for the derivative or <code>kD</code> is tuned correctly, you can see results like this.</p>
<iframe src="https://www.desmos.com/calculator/yxxnbekjuj?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>
<blockquote>
<p>Here, the robot reaches the target in a very controlled matter.</p>
</blockquote>
<p>The derivative in this context can simply be calculated by subtracting the error from the previous error like so.</p>
<pre><code class="language-cpp">float derivative = previousError - error;
</code></pre>
<p>The previous error can be found by updating it to the error after the derivative is calculated.</p>
<pre><code class="language-cpp">while...//control loop

float derivative = previousError - error;
previousError = error;
</code></pre>
<h1 id="the-full-pid-implementation"><a class="header" href="#the-full-pid-implementation">The Full PID Implementation</a></h1>
<pre><code class="language-cpp">
#include "main.h"
#include  &lt;cmath&gt;  // Include cmath for fabs()
pros::Motor lift(1, pros::E_MOTOR_GEARSET_18); // motor at port 1, green gearbox

// function to get lift motor to the target angle
void PID(float target, float deadband, float kP, 
									   float kI, 
									   float kD) {
    float error = 0;
    float integral = 0;
    float derivative = 0;
    float prevError = 0;
    float P = 0;
    float I = 0;
    float D = 0;
    
    while (fabs(deadband &gt; error)) {
        error = target - lift.get_position();
        integral += error;
        derivative = prevError - error;
        P = error * kP;
        I = integral * kI;
        D = derivative * kD;
        lift.move(P + I + D);
		
		prevError = error;
    }
}

void autonomous() {
    PID(90, 1, 0.6, 0.2, 0.05); 
}

</code></pre>
<h1 id="a-more-modular-pid-design"><a class="header" href="#a-more-modular-pid-design">A More Modular PID design</a></h1>
<p>You can write a c++ <code>class</code> for the PID.  Doing so has many benefits. With c++ classes, you can create multiple objects of the same PID. So in other words, you write the PID code once but it can get used for any other function.</p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>To begin with, inside the class, there should be a constructor like so.</p>
<pre><code class="language-cpp">class PID {
    // Constructor
    PID(float kP, float kI, float kD) 
    : kP(kP), 
      kI(kI), 
      kD(kD), 
      integral(0), 
      prevError(0) {}
};
</code></pre>
<p>By default, classes have their contents as <code>private:</code> if not specified. <code>private:</code> variables and functions can not be accessed from outside which obviously isn't helpful. This is easily solved using <code>public:</code></p>
<pre><code class="language-cpp">class PID {
	public:
    // Constructor
    PID(float kP, float kI, float kD) 
    : kP(kP), 
      kI(kI), 
      kD(kD), 
      integral(0), 
      prevError(0) {}
};
</code></pre>
<p>So what we have above is a constructor. This means that values can be passed into the class upon creation of the object. So normally, you would have to do this:</p>
<pre><code class="language-cpp">PID pid;
pid.kP = 1;
pid.kI = 1;
pid.kD = 1;
</code></pre>
<p>But with constructors,</p>
<pre><code class="language-cpp">PID pid(1,2,3); 
// constructors also get called at the creation of an object!
</code></pre>
<p>Everything after the <code>:</code> are the initial values. <code>kP</code>, <code>kD</code>, and <code>kI</code> initial values are inputted. The <code>integral</code> and <code>prevError</code>initialize at 0 which also means that they can not be initialized with an input.</p>
<h2 id="member-functions"><a class="header" href="#member-functions">Member Functions</a></h2>
<p>The next step is to make a function for calulating the output. It can be the same as previously mentioned but instead of actually controlling the motor, it outputs the velocity for the motor. The function should be <code>public:</code> so it can be accessed externally.</p>
<pre><code class="language-cpp">#include "main.h"

class PID {
    public:
    // Constructor
    PID(float kP, float kI, float kD) 
    : kP(kP), 
      kI(kI), 
      kD(kD) {}

    // Member function to update PID
    // This should be used in a control loop for a motor!
    float update(const float error) { 
        // calculate integral
        integral += error;

        // calculate derivative
        const float derivative = error - prevError;
        prevError = error;

        // calculate output
        return error * kP + integral * kI + derivative * kD;
    }
    
};
</code></pre>
<p>It is a good idea to makea <code>reset()</code> function for the <code>PID</code> class. This function should reset just the <code>integral</code> and <code>prevErorr</code> to <code>0</code> because when the loop exits, the <code>integral</code> and <code>prevErorr</code> will still be based on the previous loop. The <code>reset()</code> function can simply be:</p>
<pre><code class="language-cpp">void reset() {
	integral = 0;
	prevError = 0;
}
</code></pre>
<p>This can also be <code>public:</code> in the public keyword.</p>
<h2 id="member-variables"><a class="header" href="#member-variables">Member Variables</a></h2>
<p>All the variables can be kept within the <code>protected:</code> keyword.  This means that the variables will be inaccessable from outside but accessable by the other member functions in future uses.</p>
<pre><code class="language-cpp">    protected:
    // Member variables
    float kP;
    float kI;
    float kD;
    float integral = 0;
    float prevError = 0;
</code></pre>
<blockquote>
<p>Note: There is also a <code>private:</code> keyword that is similar to <code>protected:</code> but the private variables can not be accessed by other member functions in future uses.</p>
</blockquote>
<h2 id="full-implementation"><a class="header" href="#full-implementation">Full Implementation</a></h2>
<pre><code class="language-cpp">using namespace std;
#include &lt;cmath&gt; // Include cmath for fabs()

class PID {
    public:
    // Constructor
    PID(float kP, float kI, float kD) 
    : kP(kP), 
      kI(kI), 
      kD(kD) {}

    // Member function to update PID
    float update(const float error) {
        // calculate integral
        integral += error;

        // calculate derivative
        const float derivative = error - prevError;
        prevError = error;

        // calculate output
        return error * kP + integral * kI + derivative * kD;
    }

    // Member function to reset PID
    void reset() {
        integral = 0;
        prevError = 0;
    }

    protected:
    // Member variables
    float kP;
    float kI;
    float kD;
    float integral = 0;
    float prevError = 0;

    // Member functions can also be added here!
    
};
</code></pre>
<p>This now lets you create a <code>PID</code>object initialized with <code>kP</code>,<code>kD</code>, and <code>kI</code>. You can make however many you want and use it for whatever you want.</p>
<blockquote>
<p>The settling conditions can be created outside since the settling conditions vary from use to use.</p>
</blockquote>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Lift example:</p>
<pre><code class="language-cpp">pros::Motor lift(10, pros::E_MOTOR_GEARSET_18); // port 10, 200 RPM

void autonomous() {
	// construct liftPID off of PID class
    PID liftPID(1, 0.2, 2.5); 
    float deadband = 1; // deadband from earlier
	// settled bool to check if PID should be exited
    bool settled = false; 
    float target = 45;
    float motorPower;
    while (!settled) {
        float error = target - lift.get_position();
        motorPower = liftPID.update(error);
		// if error is less than deadband...
        if (fabs(error) &lt; deadband) { 
            settled = true; // exit
        }
    }
    liftPID.reset();
    
}
</code></pre>
<p>Flywheel example</p>
<pre><code class="language-cpp">pros::Motor flywheel(10, pros::E_MOTOR_GEARSET_06); // port 10, 600 RPM

void autonomous() {
    PID fwPID(1, 0.2, 2.5); // construst liftPID off of PID class
    float target = 450;
    float motorPower;
    while (true) {
        float error = target - flywheel.get_actual_velocity();
        motorPower = fwPID.update(error);
    }
    fwPID.reset();
}
</code></pre>
<blockquote>
<p>Flywheel control loops are often only manually exited</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: Bang Bang
author: Mannat
date: 2024-02-06 06:12:00 -0700
categories: [PID-Extensions, Introductory]
tags: [software, pid, beginner, extensions, bang-bang]     # TAG names should always be lowercase</h2>
<h1 id="bang-bang-controllers"><a class="header" href="#bang-bang-controllers">Bang Bang Controllers</a></h1>
<p>A Bang Bang Controller is a type of controller that decreases the amount of time it takes to reach the target speed by running motors at maximum power until they reach a certain threshold, after which it lapses control back to a PID loop.</p>
<h2 id="one-directional-bang-bang-controller"><a class="header" href="#one-directional-bang-bang-controller">One-directional bang-bang controller</a></h2>
<p>The following code is an example of a one-directional bang-bang controller that returns 127 when the current velocity is less than the threshold and returns the result of the PID calculation when the current velocity lies above the threshold.</p>
<pre><code class="language-cpp">float one_directional_bang_bang(float current_value, float threshold, float target_value) {
	if(current_value&lt;threshold) {
		return 127;
	}
	else {
		//assuming calculate(float current_value, float target_value) is a function that returns the pid calculation for a sensor reading.
		return 	calculate(current_value, target_value);
	}
}
</code></pre>
<h2 id="two-directional-bang-bang-controller"><a class="header" href="#two-directional-bang-bang-controller">Two-directional bang-bang controller</a></h2>
<p>An improvement over a one-directional controller is a two-directional controller; this will return control over the motor voltages to the bang-bang function whenever the abs(target-current) is greater than the threshold.</p>
<p>The most important advantage of a 2d bang_bang is that it decreases the time taken to return to the target  when the current value is greater than said target.</p>
<pre><code class="language-cpp">//returns the sign of the input value
float signbit(float value) {
	return (value &gt; 0) - (value &lt; 0);
}

float two_directional_bang_bang(float current_value, float threshold, float target_value) {
	float error = target_value - current_value;
	if(abs(error)&gt;threshold) {
		return sgn(error)*127;
	}
	else {
		//assuming calculate(float current_value, float target_value) is a function that returns the pid calculation for a sensor reading.
		return 	calculate(current_value, target_value);
	}
}

</code></pre>
<p>The 2 direction bang bang controller returns either + or - 127 (when active) depending on whether the error is positive or negative.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
